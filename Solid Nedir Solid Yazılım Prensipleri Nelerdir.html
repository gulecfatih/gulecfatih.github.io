<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Fatih Güleç</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="keywords" content="Resume Website Template Free Download">
    <meta name="description" content="Resume Website Template Free Download">

    <!-- Favicon -->
    <link rel="icon" href="img/favicon.ico">

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:300;400;600;700;800&display=swap" rel="stylesheet">

    <!-- CSS Libraries -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.10.0/css/all.min.css">
    <link rel="stylesheet" href="lib/slick/slick.css">
    <link rel="stylesheet" href="lib/slick/slick-theme.css">
    <link rel="stylesheet" href="lib/lightbox/css/lightbox.min.css">

    <!-- Template Stylesheet -->
    <link rel="stylesheet" href="css/style.css">
</head>
<body data-spy="scroll" data-target=".navbar" data-offset="51">
    <div class="wrapper">
<!-- Sidebar Start -->
<div class="sidebar">
    <div class="sidebar-content">
        <nav class="navbar navbar-expand-md bg-dark navbar-dark">
            <a href="#" class="navbar-brand">Projects</a>
            <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbarCollapse">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarCollapse">
                <ul class="nav navbar-nav">
				<li class="nav-item">
                        <a class="nav-link" style="color: royalblue;" onmouseover="this.style.color='blue'" onmouseout="this.style.color='royalblue'" href="Home.html" id="tumProjelerLink">Home</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" style="color: royalblue;" onmouseover="this.style.color='blue'" onmouseout="this.style.color='royalblue'" href="Projects.html" id="tumProjelerLink">All Projects</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" style="color: white;" onmouseover="this.style.color='darksalmon'" onmouseout="this.style.color='white'" href="Nesne Yönelimli Programlama (OOP)’nin Temel Prensipleri.html" id="proje1Link">Nesne Yönelimli Programlama (OOP)’nin Temel Prensipleri</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" style="color: white;" onmouseover="this.style.color='darksalmon'" onmouseout="this.style.color='white'" href="Solid Nedir Solid Yazılım Prensipleri Nelerdir.html" id="proje1Link">Solid Nedir ? Solid Yazılım Prensipleri Nelerdir ?</a>
                    </li>
                     <!-- Solid başlığı -->
                   <li class="nav-item">
                    <a class="nav-link" href="#" id="ApisLink">SOLID Yazılım Prensipleri</a>
                    <ul class="submenu" id="ApisSubmenu" style="display: none;">
                        <li><a href="\Pages\Solid\Single Responsibility Principle.html" style="color: white;" onmouseover="this.style.color='darksalmon'" onmouseout="this.style.color='white'">Single Responsibility Principle</a></li>
                        <li><a href="\Pages\Solid\Open-Closed Principle.html" style="color: white;" onmouseover="this.style.color='darksalmon'" onmouseout="this.style.color='white'">Open-Closed Principle</a></li>
                        <li><a href="\Pages\Solid\Liskov Substitution Principle.html" style="color: white;" onmouseover="this.style.color='darksalmon'" onmouseout="this.style.color='white'">Liskov Substitution Principle</a></li>
                        <li><a href="\Pages\Solid\Interface Segregation Principle.html" style="color: white;" onmouseover="this.style.color='darksalmon'" onmouseout="this.style.color='white'">Interface Segregation Principle</a></li>
                        <li><a href="\Pages\Solid\Dependency Inversion Principle.html" style="color: white;" onmouseover="this.style.color='darksalmon'" onmouseout="this.style.color='white'">Dependency Inversion Principle</a></li>
                        <!-- İhtiyacınıza göre diğer design pattern kategorilerini ve içeriklerini buraya ekleyebilirsiniz -->
                    </ul>
                </li>
                    <!-- Api başlığı -->
                   <li class="nav-item">
                    <a class="nav-link" href="#" id="ApisLink">API Mimari Stilleri</a>
                    <ul class="submenu" id="ApisSubmenu" style="display: none;">
                        <li><a href="ApiNedir.html" style="color: white;" onmouseover="this.style.color='darksalmon'" onmouseout="this.style.color='white'">API Nedir ?</a></li>
                        <li><a href="Rpc.html" style="color: white;" onmouseover="this.style.color='darksalmon'" onmouseout="this.style.color='white'">RPC API</a></li>
                        <li><a href="Soap.html" style="color: white;" onmouseover="this.style.color='darksalmon'" onmouseout="this.style.color='white'">SOAP API</a></li>
                        <li><a href="Rest.html" style="color: white;" onmouseover="this.style.color='darksalmon'" onmouseout="this.style.color='white'">REST API</a></li>
                        <li><a href="GraphQL.html" style="color: white;" onmouseover="this.style.color='darksalmon'" onmouseout="this.style.color='white'">GraphQL API</a></li>
                        <!-- İhtiyacınıza göre diğer design pattern kategorilerini ve içeriklerini buraya ekleyebilirsiniz -->
                    </ul>
                </li>
                   <!-- Design Patterns başlığı -->
                   <li class="nav-item">
                    <a class="nav-link" href="#" id="designPatternsLink">Design Patterns</a>
                    <ul class="submenu" id="designPatternsSubmenu" style="display: none;">
                        <li><a href="#" style="color: white;" onmouseover="this.style.color='darksalmon'" onmouseout="this.style.color='white'">Creational Patterns</a></li>
                        <li><a href="#" style="color: white;" onmouseover="this.style.color='darksalmon'" onmouseout="this.style.color='white'">Structural Patterns</a></li>
                        <li><a href="#" style="color: white;" onmouseover="this.style.color='darksalmon'" onmouseout="this.style.color='white'">Behavioral Patterns</a></li>
                        <!-- İhtiyacınıza göre diğer design pattern kategorilerini ve içeriklerini buraya ekleyebilirsiniz -->
                    </ul>
                </li>
                <!-- İhtiyacınıza göre diğer projeleri buraya ekleyebilirsiniz -->
                </ul>
            </div>
        </nav>
    </div>
</div>
<!-- Sidebar End -->


<!-- Content Start -->
<div class="content">
    <div class="content-inner" style="background-color: white;">
        <div class="header">
            <div class="content-inner">
                 <h1>SOLID Prensipleri</h1>
            </div>
        </div>
        <div><ol>
            <p>SOLID prensipleri, yazılım geliştirme ve özellikle nesne yönelimli programlama (OOP) alanında önemli bir rol oynar. SOLID prensipleri, yazılımın esnek, sürdürülebilir, okunabilir ve yeniden kullanılabilir olmasını sağlamak için geliştirilen bir dizi tasarım prensibidir.</p>
            <p>SOLID prensipleri, sıkı bağlantıyı (tight coupling) azaltmaya ve gevşek bağlantıyı (loose coupling) kullanmaya yardımcı olur.</p>
            <p>Sıkı bağlantı, bir sınıfın veya modülün diğer sınıflara veya modüllere güçlü bir şekilde bağımlı olduğu durumları ifade eder. Bu durumda, bir değişiklik yapmak veya bir sınıfı değiştirmek diğer bağımlı sınıfları etkileyebilir ve büyük bir kod değişikliği gerektirebilir. Kodunuzda bundan kaçınmanız gerekir.</p>
            <p>Gevşek bağlantı ise bir sınıfın veya modülün dışarıdan bağımlılıkları azaltıldığında veya soyutlanarak bağımsız hale getirildiğinde ortaya çıkar. Bu durumda, bir sınıfın veya modülün içinde yapılan değişiklikler diğer bağımlı bileşenlere çok az veya hiç etki etmez. Bu, kodunuzdaki değişiklikleri en aza indirir, kodun daha yeniden kullanılabilir, bakımı yapılabilir, esnek ve kararlı olmasına yardımcı olur.</p>
            <p>Yazılım geliştirme alanında “Solid” terimi, SOLID prensiplerine atıfta bulunur. SOLID, yazılım tasarımı ve kodlama için kullanılan beş temel prensibi ifade eder.</p>
                <!-- Single Responsibility Principle Start -->
                
            <h3>(S) Single Responsibility Principle (Tek Sorumluluk Prensibi - SRP)</h3><br>

            <p style="font-style: italic; font-weight: bold; background-color: #f0f0f0;">Bir sınıfın sadece bir sorumluluğu olmalıdır.</p><br>
            <pre><code class="language-csharp">
public class LogModifier
{
    public string ModifyLogMessage(string originalMessage)
    {
        // Log mesajını düzenleme işlemleri
    }
}

public class DatabaseSave
{
    public void SaveToDatabase(string message)
    {
        // Veritabanına yazma işlemleri
    }
}
            </code></pre>
			<br>

            <p>Elimizde iki farklı sınıf bulunmaktadır. İlk sınıf, loglama işleminin tamamlandığı noktada string ifademizi düzenleyen bir sınıftır. Bu düzenleme işlemi sırasında (Harfleri büyültülebilir, bazı karakterleri yok edilebilir veya eklenebilir) gibi işlemler uygulanabilir. Diğer sınıf ise, bu düzenlenmiş ifadeyi veritabanına kaydetme işlemini gerçekleştirir. Bu iki işlem farklı olduğu için her biri için ayrı bir sınıf kullanılmalıdır. Veritabanı işlemlerini yapan sınıf sadece veritabanı işlemleri yapmalı, log düzenlemeyi gerçekleştiren sınıf ise sadece log düzenleme işlevini yerine getirmelidir.</p>
			<!-- Single Responsibility Principle Finish -->
            <!-- Open-Closed Principle (Açık/Kapalı Prensibi - OCP) Start -->
            <h3>(O) Open-Closed Principle (Açık/Kapalı Prensibi - OCP)</h3><br>

			 <p style="font-style: italic; font-weight: bold; background-color: #f0f0f0;">Bir sınıf gelişime açık, ancak değişime kapalı olmalıdır.</p><br>
            <pre><code class="language-csharp">
// Şema diye bir Interface
public interface IShape
{
    double Area();
}

// Dikdörtgen sınıfı
public class Rectangle : IShape
{
    public double Width { get; set; }
    public double Height { get; set; }

    public double Area()
    {
        return Width * Height;
    }
}
                    </code></pre><br>
                    <p>IShape(Şema) arayüzü, Açık/Kapalı Prensibi’ne uygundur çünkü IShape arayüzü, Area fonksiyonunu zorunlu olarak içerir ve her sınıf, kendi içinde bu fonksiyonu ekleyerek alanını hesaplamasını gerektiren bir yapıya sahiptir. Örneğin, Daire sınıfını bu yapıya uygun olarak ekleyelim; Daire sınıfı da aynı arayüzü (IShape) implementasyonu ile almalıdır.</p><br>
                    <pre><code class="language-csharp">
// Daire sınıfı
public class Circle : IShape
{
    public double Radius { get; set; }

    public double Area()
    {
        return Math.PI * Math.Pow(Radius, 2);
    }
}
                    </code></pre><br>
                    <p>Yukarıdaki örnekte, IShape arayüzü, farklı şekillerin ortak bir davranışını temsil eder. Bu arayüzü uygulayan her sınıf, Area metodunu implemente etmek zorundadır. Bu sayede, tüm şekillerin alanlarını hesaplamak için ortak bir arayüz sağlanmış olur.</p><br>
					<!-- Open-Closed Principle (Açık/Kapalı Prensibi - OCP) Finish -->
                    <!-- Liskov Substitution Principle (Liskov Yerine Koyma Prensibi Start -->
					<h3>(L) Liskov Substitution Principle (Liskov Yerine Koyma Prensibi - LSP)</h3><br>

					<p style="font-style: italic; font-weight: bold; background-color: #f0f0f0;">Alt sınıflar, üst sınıfların yerine geçebilmelidir.</p><br>
                    <pre><code class="language-csharp">
// Şema sınıfı
public class Shape
{
    public virtual void Draw()
    {
        Console.WriteLine("Drawing a shape");
    }
}

// Daire sınıfı
public class Circle : Shape
{
    public override void Draw()
    {
        Console.WriteLine("Drawing a circle");
    }
}

// Program.cs

static void DrawShape(Shape shape)
{
    shape.Draw();
}

static void Main()
{
    Shape shape = new Shape();
    Circle circle = new Circle();

    DrawShape(shape);  // "Drawing a shape"
    DrawShape(circle); // "Drawing a circle"
}
                    </code></pre><br>
                    <p>Örnek kodumuzda Shape üst sınıfı ve ondan türetilen Circle alt sınıfı var. Her iki alt sınıf da Shape sınıfından türediği için, DrawShape fonksiyonu içinde bu alt sınıfları, üst sınıf olan Shape tipindeki bir değişkenle kullanabiliyoruz. Bu durum LSP'ye uyar, çünkü alt sınıflar, üst sınıfların yerine geçebilir ve beklenen davranışları (burada Draw metodunu) sergiler.</p>
					<br>
					 <!-- Liskov Substitution Principle (Liskov Yerine Koyma Prensibi Start -->
                    <!-- Interface Segregation Principle Start -->
					<h3>Interface Segregation Principle (Arayüz Ayrımı Prensibi - ISP)</h3><br>

					<p style="font-style: italic; font-weight: bold; background-color: #f0f0f0;">Bir sınıf, kullanmadığı metotları almamalı ve bir arayüzü yalnızca ihtiyaç duyulan metotları içermesi gerekir.</p>
					<br>
<pre><code class="language-csharp">//Ortak Özellikleri
public interface IWorker
{
    void Work();
}

//Robota Özgü Özellikleri
public interface IRobot
{
    void ChargeBattery();
}


//İnsana Özgü Özellikleri
public interface IHuman
{
    void Sleep();
}

//İnsan Sınıfı
public class Human : IWorker, IHuman
{
    public void Work()
    {
        Console.WriteLine("İnsan çalışıyor.");
        // Ortak çalışma davranışları burada gerçekleştirilir
    }

    public void Sleep()
    {
        Console.WriteLine("İnsan uyuyor.");
        // İnsana özgü uyuma davranışları burada gerçekleştirilir
    }
}

//Robot Sınıfı
public class Robot : IWorker, IRobot
{
    public void Work()
    {
        Console.WriteLine("Robot çalışıyor.");
       // Ortak çalışma davranışları burada gerçekleştirilir
    }

    public void ChargeBattery()
    {
        Console.WriteLine("Robot bataryasını şarj ediyor.");
        // Robota özgü şarj etme davranışları burada gerçekleştirilir
    }
}
</code></pre><br>
<p>Bir IWorker arayüzü üzerinden ortak çalışma davranışlarını tanımlayabiliriz. Ancak, insan ve robot sınıfları arasında ortak olmayan özellikleri, IHuman ve IRobot arayüzleri ile belirleyebiliriz. Bu, her iki sınıfın da sadece kendi özel özelliklerine odaklanmasını sağlar ve gereksiz bağımlılıkları ortadan kaldırır. Her sınıf, yalnızca kendi sorumluluklarına odaklanarak, gereksiz metodların kullanılmasının önüne geçilmiş olur.</p><br>

              <!-- Interface Segregation Principle Finish -->
              <!-- Dependency Inversion Principle Start -->
			<h3>(D) Dependency Inversion Principle (Bağımlılıkların Ters Çevrilmesi Prensibi - DIP)</h3><br>

			<p style="font-style: italic; font-weight: bold; background-color: #f0f0f0;">Yüksek seviyeli modüller, düşük seviyeli modüller tarafından bağımlı olmamalıdır. Her iki seviyede soyutlamalara (abstraction) bağlı olmalıdır.</p>
                <br>
				<pre><code class="language-csharp">
				// Ortak Özellikler
public interface ILightBulb
{
    void TurnOn();
    void TurnOff();
}

// RemoteControl sınıfı, ILightBulb arayüzüne bağlıdır ve ışığı kontrol eder.
public class RemoteControl
{
    private readonly ILightBulb lightBulb;

    // ILightBulb arayüzü üzerinden bağımlılık enjeksiyonu yapılır.
    public RemoteControl(ILightBulb lightBulb)
    {
        this.lightBulb = lightBulb;
    }

    public void PressButton()
    {
        // Uzaktan kumanda düğmesine basıldığında ışığı açma veya kapatma işlemi
        if (lightBulb != null)
        {
            Console.WriteLine("Button pressed. Controlling the light.");
            lightBulb.TurnOn();
            lightBulb.TurnOff();
        }
    }
}

// IncandescentBulb sınıfı, ILightBulb arayüzünü uygular ve ampulü kontrol eder.
public class IncandescentBulb : ILightBulb
{
    public void TurnOn()
    {
        Console.WriteLine("Incandescent bulb is ON.");
    }

    public void TurnOff()
    {
        Console.WriteLine("Incandescent bulb is OFF.");
    }
}

// LEDBulb sınıfı, ILightBulb arayüzünü uygular ve LED ışığı kontrol eder.
public class LEDBulb : ILightBulb
{
    public void TurnOn()
    {
        Console.WriteLine("LED bulb is ON.");
    }

    public void TurnOff()
    {
        Console.WriteLine("LED bulb is OFF.");
    }
}

class Program
{
    static void Main()
    {
        // Bağımlılık enjeksiyonu ile IncandescentBulb kullanarak RemoteControl sınıfını başlatma
        RemoteControl remoteControlForIncandescentBulb = new RemoteControl(new IncandescentBulb());
        remoteControlForIncandescentBulb.PressButton();

        // Bağımlılık enjeksiyonu ile LEDBulb kullanarak RemoteControl sınıfını başlatma
        RemoteControl remoteControlForLEDBulb = new RemoteControl(new LEDBulb());
        remoteControlForLEDBulb.PressButton();
    }
}
				</code></pre>
				<br>

				 <h5>ILightBulb Arayüzü:</h5>
				 <ul>
					<li>ILightBulb arayüzü, ampulü kontrol etmek için kullanılacak metodları içerir. Her ampul türü bu arayüzü uygular.</li>
				</ul><br>
				<h5>RemoteControl Sınıfı:</h5>
				<ul>
					<li>Yüksek seviyeli bir modüldür ve bir ILightBulb arayüzüne bağlıdır.</li>
					<li>Constructor aracılığıyla bir ILightBulb örneği alır. Bu, bağımlılık enjeksiyonunu temsil eder.</li>
					<li>PressButton metodu, uzaktan kumandanın düğmesine basıldığında çalışır. Bu metod, bağlı olduğu ampulü açma ve kapatma işlemlerini gerçekleştirir.</li>
				</ul>
				<br>
				<h5>IncandescentBulb ve LEDBulb Sınıfları:</h5><br>
				<ul>
					<li>IncandescentBulb ve LEDBulb sınıfları, ILightBulb arayüzünü uygular.</li>
					<li>Her biri kendi türündeki ampulü temsil eder ve TurnOn ve TurnOff metodlarıyla ampulün açılması ve kapatılması işlemlerini gerçekleştirir.</li>
				</ul>
				<br>
				<h5>Program Sınıfı (Main Metodu):</h5>
				<ul>
					<li>İlk olarak, IncandescentBulb tipinde bir ampul için bir RemoteControl örneği oluşturulur ve düğmeye basılarak ampul açılıp kapatılır.</li>
					<li>Ardından, LEDBulb tipinde bir ampul için başka bir RemoteControl örneği oluşturulur ve aynı şekilde düğmeye basılarak ampul açılıp kapatılır.</li>
				</ul><br>
				<h5>Özet</h5><br>
				<p>Her iki ampul çeşidini (IncandescentBulb ve LEDBulb) tek bir RemoteControl (uzaktan kumanda) sınıfı üzerinden kontrol etmemizi sağlayan şey, ILightBulb arayüzü sayesindedir. Bu arayüz, ampullerin ortak bir soyutlamasını sağlar ve RemoteControl sınıfı, ampullerle bu soyutlama üzerinden etkileşimde bulunur. Böylece, farklı ampul türlerini tek bir uzaktan kumanda aracılığıyla kontrol etmek mümkün hale gelir. Yeni bir ampul türü eklemek istediğinizde, sadece ILightBulb arayüzünü uygulamanız ve RemoteControl sınıfına bu yeni ampul türünü enjekte etmeniz yeterli olacaktır.</p>
             <!-- Dependency Inversion Principle Finish -->
            </ol>
        </div>
    </div>
</div>
<!-- Content End -->



    </div>
    
    <!-- Back to Top -->
    <a href="#" class="back-to-top"><i class="fa fa-angle-double-up"></i></a>
    
    <!-- JavaScript Libraries -->
    <script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.bundle.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/prismjs@1.25.0"></script>
    <script src="lib/easing/easing.min.js"></script>
    <script src="lib/slick/slick.min.js"></script>
    <script src="lib/typed/typed.min.js"></script>
    <script src="lib/waypoints/waypoints.min.js"></script>
    <script src="lib/isotope/isotope.pkgd.min.js"></script>
    <script src="lib/lightbox/js/lightbox.min.js"></script>
	<!-- Prism.js için C# dil dosyası -->
	<script src="https://cdn.jsdelivr.net/npm/prismjs@1.25.0/components/prism-csharp.min.js"></script>
	<!-- Prism.js için bir tema dosyası -->
	<link href="https://cdn.jsdelivr.net/npm/prismjs@1.25.0/themes/prism-okaidia.css" rel="stylesheet">
    
    <!-- Template Javascript -->
    <script src="js/main.js"></script>
</body>
</html>
